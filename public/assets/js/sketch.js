var wv1,wv2,wv3,audioCtx,analyser,bufferLength,freqs,normSpectrum, normFoldSpectrum,bandRatio;

function setup() {


    var cnv = createCanvas(windowWidth, windowHeight/2);
    cnv.parent('display');
    
    wv1 = new Tone.Waveform(1024);
    wv2 = new Tone.Waveform(1024);
    wv3 = new Tone.Waveform(1024);
    gainNode1.connect(wv1);
    gainNode2.connect(wv2);
    gainNode3.connect(wv3);
    
    audioCtx = gainNode1.context;
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;    
    bufferLength = analyser.frequencyBinCount;
    normSpectrum = new Uint8Array(bufferLength);
    bandRatio = 32;
    freqs = [];
    for(i=0;i<analyser.fftSize/2;i++) {
        freqs[i] = i/(analyser.fftSize/2-1)*audioCtx.sampleRate/2;
    }
    console.log(freqs);
    gainNode1.connect(analyser);
    gainNode2.connect(analyser);
    gainNode3.connect(analyser);

}

function draw() {


    //background(colorPalette[0]);
    background("#000000");
    analyser.getByteFrequencyData(normSpectrum);
    
    var waveform1 = wv1.getValue();
    var waveform2 = wv2.getValue();
    var waveform3 = wv3.getValue();
    var mapwv1 = [];
    var mapwv2 = [];
    var mapwv3 = [];
    
    for (i=0;i<waveform1.length;i++) {
        mapwv1[i] = map(waveform1[i], -1, 1, -2, 2);
        mapwv2[i] = map(waveform2[i], -1, 1, -2, 2);
        mapwv3[i] = map(waveform3[i], -1, 1, -2, 2);
    }
    
    //"Pseudo" spectrogram of the sound generated by the user
    
    /*for (var i = 0; i < normSpectrum.length/2; i++) {
        fill(255, normSpectrum[i], 0);
        var x = map(i, 0, normSpectrum.length/2, 0, width);
        var h = map(normSpectrum[i], 0, 255, 0, height);
        rect(x, height, 2, -h);
    }*/
    
    normFoldSpectrum = computeFoldedSpectrum(analyser);
    //console.log(normFoldSpectrum.length);
    for (var i = 0; i < normFoldSpectrum.length/3; i++) {
        fill(255, normFoldSpectrum[i], 0);
        var x = map(i, 0, normFoldSpectrum.length/3, 0, width);
        var h = map(normFoldSpectrum[i], 0, 255, 0, height);
        rect(x, height, 2, -h);
    }
    
    //console.log(computeSpectralCentroid(normSpectrum,freqs,bandRatio));
    // plot the Spectral Envelope (MPG-7)
    /*var normBands = computeFrequencyBandNormalizedEnergy(normSpectrum,bandRatio);
    console.log(normBands);
    for (var i = 0; i < normBands.length; i++) {
        var max = Math.max.apply(null,normBands);
        fill(255, normBands[i], 0);
        var x = map(i, 0, normSpectrum.length/bandRatio, 0, width);
        var h = map(normBands[i], 0, max, 0, height);
        rect(x, height, normSpectrum.length/bandRatio, -h);
    }*/
    
    //Draw a custom polygon with the line corresponding to the waveform of the oscillator1, radius varying with the envelope1 waveform
    fill('#1a53ff');
    stroke(0);
    push();
    translate(width/4, height*0.5);
    waveformPolygon(mapwv1, 10+env1.value*100); 
    pop();
    
    //Draw a custom polygon with the line corresponding to the waveform of the oscillator2, radius varying with the envelope2 waveform
    fill("#9966ff");
    stroke(0);
    push();
    translate(width*0.5, height*0.5);
    waveformPolygon(mapwv2, 10+env2.value*100); 
    pop();
    
    //Draw a custom polygon with the line corresponding to the waveform of the oscillator3, radius varying with the envelope3 waveform
    fill("#e60000");
    stroke(0);
    push();
    translate(width*0.8, height*0.5);
    waveformPolygon(mapwv3, 10+env3.value*100); 
    pop();
    

}

function waveformPolygon(waveform, radius) {
  var angle = TWO_PI / waveform.length;
  beginShape();
  for (var i = 0; i < waveform.length; i ++) {
    var a = angle*i;
    var sx =  cos(a) * radius;
    var sy =  sin(a) * (radius+waveform[i]);
    vertex(sx, sy);
  }
  endShape(CLOSE);
}


function computeFrequencyBandNormalizedEnergy(normSpectrum,bandRatio) {
    
    var normBands = new Float32Array(normSpectrum.length/bandRatio);
    var normSum = 0;
    for (i=0;i<normSpectrum.length;i++) {
        normSum+=normSpectrum[i];
        if(((i+1)%bandRatio)==0){
            
            normBands[Math.floor(i/bandRatio)]=normSum/bandRatio;
            normSum=0;
        }
    }
    
    return normBands;
    
}

function computeFoldedSpectrum(analyzer) {
    var rangeDB = analyzer.maxDecibels - analyzer.minDecibels;
    var floatfrequencydata = new Float32Array(analyzer.fftSize);
    analyzer.getFloatFrequencyData(floatfrequencydata);
    var logconversion = Math.log(2)/Math.log(10);
    //floatfrequencydata = floatfrequencydata + 3;
    var normFoldSpectrum = [];
    for (i=0;i<floatfrequencydata.length/2;i++) {
        normFoldSpectrum[i] = Math.floor((255/rangeDB)*(floatfrequencydata[i]-analyzer.minDecibels+3));
        if (normFoldSpectrum[i]>255) {
            normFoldSpectrum[i] = 255;
        }
        else if (normFoldSpectrum[i]<0) {
            normFoldSpectrum[i] = 0;
        }
    }
    return normFoldSpectrum;
}

function computeSpectralCentroid(normSpectrum,freqs,bandRatio) {
    //compute the spectral centroid
    var num=0,den=0;
    for(i=0;i<normSpectrum.length;i++) {
        num+=freqs[i]*normSpectrum[i];
        den+=normSpectrum[i];
    }
    if (den!=0) {
        return num/den;
    }
    else {
        return 0;
    }
}