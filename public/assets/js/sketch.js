var wv1,wv2,wv3,audioCtx,masterAnalyser,analyser1,analyser2,analyser3,bufferLength,freqs,normFoldSpectrum,bandRatio;

function setup() {


    var cnv = createCanvas(windowWidth, windowHeight/2);
    cnv.parent('display');
    
    wv1 = new Tone.Waveform(1024);
    wv2 = new Tone.Waveform(1024);
    wv3 = new Tone.Waveform(1024);
    gainNode1.connect(wv1);
    gainNode2.connect(wv2);
    gainNode3.connect(wv3);
    
    audioCtx = gainNode1.context;
    masterAnalyser = audioCtx.createAnalyser();
    analyser1 = audioCtx.createAnalyser(); 
    analyser2 = audioCtx.createAnalyser(); 
    analyser3 = audioCtx.createAnalyser(); 
    bufferLength = masterAnalyser.frequencyBinCount;
    normSpectrum = new Uint8Array(bufferLength);
    bandRatio = 32;
    freqs = [];
    for(i=0;i<masterAnalyser.fftSize/2;i++) {
        freqs[i] = i/(masterAnalyser.fftSize/2-1)*audioCtx.sampleRate/2;
    }
    console.log(freqs);
    gainNode1.connect(analyser1);gainNode1.connect(masterAnalyser);
    gainNode2.connect(analyser2);gainNode2.connect(masterAnalyser);
    gainNode3.connect(analyser3);gainNode3.connect(masterAnalyser);

}

function draw() {

    
    background("#000000");
    
    var waveform1 = wv1.getValue();
    var waveform2 = wv2.getValue();
    var waveform3 = wv3.getValue();
    var mapwv1 = [];
    var mapwv2 = [];
    var mapwv3 = [];
    
    for (i=0;i<waveform1.length;i++) {
        mapwv1[i] = map(waveform1[i], -1, 1, -2, 2);
        mapwv2[i] = map(waveform2[i], -1, 1, -2, 2);
        mapwv3[i] = map(waveform3[i], -1, 1, -2, 2);
    }
    
    //"Pseudo" spectrogram of the sound generated by the user for the oscillator1
    normFoldSpectrum = computeFoldedSpectrum(analyser1);
    //console.log(normFoldSpectrum.length);
    for (var i = 0; i < normFoldSpectrum.length/3; i++) {
        fill(26, 83, normFoldSpectrum[i]);
        var x = map(i, 0, normFoldSpectrum.length/3, 0, width);
        var h = map(normFoldSpectrum[i], 0, 255, 0, height);
        rect(x, height, 2, -h);
    }
    
    //"Pseudo" spectrogram of the sound generated by the user for the oscillator2
    normFoldSpectrum = computeFoldedSpectrum(analyser2);
    //console.log(normFoldSpectrum.length);
    for (var i = 0; i < normFoldSpectrum.length/3; i++) {
        fill(0, normFoldSpectrum[i], 0);
        var x = map(i, 0, normFoldSpectrum.length/3, 0, width);
        var h = map(normFoldSpectrum[i], 0, 255, 0, height);
        rect(x, height, 2, -h);
    }
    
    //"Pseudo" spectrogram of the sound generated by the user for the oscillator3
    normFoldSpectrum = computeFoldedSpectrum(analyser3);
    //console.log(normFoldSpectrum.length);
    for (var i = 0; i < normFoldSpectrum.length/3; i++) {
        fill(normFoldSpectrum[i], 0, 0, [0.8]);
        var x = map(i, 0, normFoldSpectrum.length/3, 0, width);
        var h = map(normFoldSpectrum[i], 0, 255, 0, height);
        rect(x, height, 2, -h);
    }
    
    //Spectral centroid for the master signal
    normFoldSpectrum = computeFoldedSpectrum(masterAnalyser);
    var spectralCentroid = computeSpectralCentroid(normFoldSpectrum,freqs);
    for (var i=0; i<normFoldSpectrum.length/3;i++) 
    {
        fill(255,normFoldSpectrum[i],0);
        var index = (spectralCentroid*masterAnalyser.fftSize/2)/(audioCtx.sampleRate/2);
        /*console.log(index);
        console.log(spectralCentroid);*/
        var x = map(index,0,normFoldSpectrum.length/3,0,width);
        var h = map(normFoldSpectrum[i],0,255,0,height);
        rect(x,height,10,-h);
    }
        
    
    //Draw a custom polygon with the line corresponding to the waveform of the oscillator1, radius varying with the envelope1 waveform
    fill('#1a53ff');
    stroke(0);
    push();
    translate(width/4, height*0.5);
    waveformPolygon(mapwv1, 10+env1.value*100); 
    pop();
    
    //Draw a custom polygon with the line corresponding to the waveform of the oscillator2, radius varying with the envelope2 waveform
    fill("#00ff00");
    stroke(0);
    push();
    translate(width*0.5, height*0.5);
    waveformPolygon(mapwv2, 10+env2.value*100); 
    pop();
    
    //Draw a custom polygon with the line corresponding to the waveform of the oscillator3, radius varying with the envelope3 waveform
    fill("#e60000");
    stroke(0);
    push();
    translate(width*0.8, height*0.5);
    waveformPolygon(mapwv3, 10+env3.value*100); 
    pop();
    

}

function waveformPolygon(waveform, radius) {
  var angle = TWO_PI / waveform.length;
  beginShape();
  for (var i = 0; i < waveform.length; i ++) {
    var a = angle*i;
    var sx =  cos(a) * radius;
    var sy =  sin(a) * (radius+waveform[i]);
    vertex(sx, sy);
  }
  endShape(CLOSE);
}


function computeFoldedSpectrum(analyzer) {
    //compute a normalized and folded version of the spectrum
    //the normalization follows the one executed by the AnalyserNode following the WebAudio API specification for the getByteFrequencyData method (see https://webaudio.github.io/web-audio-api/#dom-analysernode-getbytefrequencydata)
    var rangeDB = analyzer.maxDecibels - analyzer.minDecibels;
    var floatfrequencydata = new Float32Array(analyzer.fftSize);
    analyzer.getFloatFrequencyData(floatfrequencydata);
    var normFoldSpectrum = [];
    for (i=0;i<floatfrequencydata.length/2;i++) {
        normFoldSpectrum[i] = Math.floor((255/rangeDB)*(floatfrequencydata[i]-analyzer.minDecibels+3));
        if (normFoldSpectrum[i]>255) {
            normFoldSpectrum[i] = 255;
        }
        else if (normFoldSpectrum[i]<0) {
            normFoldSpectrum[i] = 0;
        }
    }
    return normFoldSpectrum;
}

function computeSpectralCentroid(normSpectrum,freqs) {
    //compute the spectral centroid
    var num=0,den=0;
    for(i=0;i<normSpectrum.length;i++) {
        num+=freqs[i]*normSpectrum[i];
        den+=normSpectrum[i];
    }
    if (den!=0) {
        return num/den;
    }
    else {
        return 0;
    }
}